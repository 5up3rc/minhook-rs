initSidebarItems({"enum":[["Error","The error type for all hooking operations.MinHook error status codes map directly to this type."],["FunctionName","A function name used for dynamically hooking a function."]],"fn":[["uninitialize","Uninitializes the minhook-rs library.SafetyThis function is unsafe because any live hooks might still depend on this library. After calling this function existing trampoline functions might point to uninitialized memory. Only use this function when you are absolutely sure no hook objects will be accessed after its use."]],"macro":[["static_hooks!","Defines one or more static hooks.A `static_hooks!` block can contain one or more hook definitions of the following forms:All of the above definitions create a static variable with the specified name of type `StaticHook` or `StaticHookWithDefault` for a target function of the given type. If the function signature contains `extern`, any panics that happen inside of the detour `Fn` are automatically caught before they can propagate across foreign code boundaries. See the `panic` submodule for more information.The first two forms create a static hook with a default detour `Fn`. This is useful if the detour `Fn` is a closure that does not need to capture any local variables or if the detour `Fn` is just a normal function. See `StaticHookWithDefault`.The last two forms require a `Fn` to be supplied at the time of initialization of the static hook. In this case a closure that captures local variables can be supplied. See `StaticHook`.The first and third forms are used for hooking functions by their compile-time identifier.The second and fourth form will try to find the target function by name at initialization instead of at compile time. These forms require the exported function symbol name and its containing module's name to be supplied.The optional `pub` keyword can be used to give the resulting hook variable public visibility. Any attributes used on a hook definition will be applied to the resulting hook variable."]],"mod":[["function","Module containing information about hookable functions.The traits in this module are automatically implemented and should generally not be implemented by users of this library."],["panic","Panic handling for panics caught at foreign code boundaries in detour functions."]],"struct":[["Hook","A hook that is destroyed when it goes out of scope."],["HookQueue","A queue of hook changes to be applied at once."],["StaticHook","A hook with a static lifetime.This hook can only be constructed using the `static_hooks!` macro. It has one of the following forms:Before accessing this hook it is **required** to call `initialize()` **once**. Accessing the hook before initializing or trying to initialize the hook twice (even after the first attempt failed) will result in a panic."],["StaticHookWithDefault","A hook with a static lifetime and a default detour closure.This hook can only be constructed using the `static_hooks!` macro. It has one of the following forms:Before accessing this hook it is **required** to call `initialize()` **once**. Accessing the hook before initializing or trying to initialize the hook twice (even after the first attempt failed) will result in a panic."]],"type":[["Result","Result type for most functions and methods in this module."]]});